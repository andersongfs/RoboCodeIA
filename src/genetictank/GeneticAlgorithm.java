package genetictank;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public class GeneticAlgorithm {
	/**
	 * Params to geneticAlgorithm
	 */
	private int POPULATION_SIZE = 20;
	private int MIN_BULLET_POWER = 1;
	private int MAX_BULLET_POWER = 3;
	private int MAX_NUMBER_OF_GENERATIONS = 9999;
	private int RENEWER_POPULATION_RATE = 20;
	private int CHROMOSOME_PARAMS_SIZE = 9; // QUANTITY OF MOVES AND ROTATIONS THAT A CHROMOSOME MUST HAVE
	private int MUTATION_RATE = 20;

	private Population population;
	private int numberOfGenerations =0;
	
	private Chromosome currentChromo;
	private int currentChromoIndex = 0;
	private int roundCounter = 0;

	private static GeneticAlgorithm ag;
	
	private GeneticAlgorithm(){
		renewPopulation();
		
	}
	public static GeneticAlgorithm getInstance(){
		if(ag == null){
			ag = new GeneticAlgorithm();
		}
		return ag;
		
	}
	public void generateRandomPopulation(){
		population = new Population(POPULATION_SIZE);
		for(int i = 0; i < POPULATION_SIZE; i++){
			population.addChromosome(generateRandomChromosome(i));
		}
		currentChromo = population.get(currentChromoIndex);
	}

	private Chromosome generateRandomChromosome(int id) {
		Chromosome chromosome = new Chromosome(id);
		List<Double> rotations = new ArrayList<Double>();
		List<Double> moves = new ArrayList<Double>();

		for(int i = 0; i < CHROMOSOME_PARAMS_SIZE; i++) {
			rotations.add((double)randomInt(0, 180));
			moves.add((double)randomInt(100, 500));
		}

		chromosome.setRotations(rotations);
		chromosome.setDistances(moves);
		chromosome.setBulletPower(randomInt(MIN_BULLET_POWER, MAX_BULLET_POWER));
		return chromosome;

	}
	
	public void renewPopulation(){
		if(population == null ){
			generateRandomPopulation();
			return;
		}
		
		List<Chromosome> bestsChromosomes = selection(population);
		List<Chromosome> children = new ArrayList<Chromosome>();
		int size = bestsChromosomes.size() - 1;
		
		while(children.size() < bestsChromosomes.size()){
			//TODO implement the roulette wheel method
			Chromosome parent1 = bestsChromosomes.get(randomInt(0, size));
			Chromosome parent2 = bestsChromosomes.get(randomInt(0, size));
			
			Chromosome[] newBorns = crossOver(parent1, parent2);
			children.add(newBorns[0]);
			children.add(newBorns[1]);
		}
		
		List<Chromosome> newPopulation = population.getPopulation();
		
		for (int i = 0; i < children.size(); i++) {
			newPopulation.set(i, children.get(i));
		}
		for (int i = 0; i < newPopulation.size(); i++) {
			newPopulation.get(i).setFitness(0);
		}
		numberOfGenerations++;
		System.out.println("Generations: "+numberOfGenerations);
		System.out.println("Children: "+Arrays.toString(children.toArray()));
		System.out.println("OLD: "+Arrays.toString(population.getPopulation().toArray()));
		System.out.println("NEW :"+Arrays.toString(newPopulation.toArray()));
		population.setPopulation(newPopulation);
	}
	
	public int getNumberOfGenerations() {
		return numberOfGenerations;
	}

	public void setNumberOfGenerations(int numberOfGenerations) {
		this.numberOfGenerations = numberOfGenerations;
	}

	/**
	 * Select the best chromosomes from a given population based on the renewer rate
	 * @param population
	 * @return
	 */
	private List<Chromosome> selection(Population population){
		Collections.sort(population.getPopulation());
		int firstIndex = POPULATION_SIZE-RENEWER_POPULATION_RATE;
		return population.getPopulation().subList(firstIndex, POPULATION_SIZE-1);
	}
	
	/**
	 * returns a list with the two chromosomes generated by the crossOver of the two given ones 
	 * @param c1 
	 * @param c2
	 * @return
	 */
	private Chromosome[] crossOver(Chromosome c1, Chromosome c2){
		Chromosome r1 = new Chromosome(randomInt(0, 999999999));
		Chromosome r2 = new Chromosome(randomInt(0, 999999999));
		
		int splitPoint = randomInt(0, CHROMOSOME_PARAMS_SIZE-1);
		
		List<Double> rotationR1 = new ArrayList<Double>();
		List<Double> rotationR2 = new ArrayList<Double>();
		List<Double> distanceR1 = new ArrayList<Double>();
		List<Double> distanceR2 = new ArrayList<Double>();
		
		for (int i = 0; i < splitPoint; i++) {
			rotationR1.add(c1.getNextRotations().get(i));
			distanceR1.add(c1.getDistances().get(i));
		
			rotationR2.add(c2.getNextRotations().get(i));
			distanceR2.add(c2.getDistances().get(i));
		}
		
		for (int i = splitPoint; i < CHROMOSOME_PARAMS_SIZE; i++) {
			rotationR1.add(c2.getNextRotations().get(i));
			distanceR1.add(c2.getDistances().get(i));
			
			rotationR2.add(c1.getNextRotations().get(i));
			distanceR2.add(c1.getDistances().get(i));
		}
		
		r1.setDistances(distanceR1);
		r1.setRotations(rotationR1);
		
		r2.setDistances(distanceR2);
		r2.setRotations(rotationR2);
		
		if(randomInt(0,1)!= 0){
			r1.setBulletPower(c1.getBulletPower());
			r2.setBulletPower(c2.getBulletPower());
		}else{
			r1.setBulletPower(c2.getBulletPower());
			r2.setBulletPower(c1.getBulletPower());
		}
		
		mutate(r1);
		mutate(r2);
		
		Chromosome[] result = {r1,r2};
		return result;
	}
	
	private void mutate(Chromosome c){
		boolean isUpToMutation = randomInt(0, MUTATION_RATE) == 5;
		if(isUpToMutation){
			int rotationSize = c.getNextRotations().size()-1;
			int distancesSize = c.getDistances().size()-1;
			Double newRotation = (double) randomInt(0, 180);
			Double newDistance = (double) randomInt(100, 500);
			c.getNextRotations().set(randomInt(0, rotationSize), newRotation);
			c.getDistances().set(randomInt(0, distancesSize),newDistance);			
		}
	}

	private int randomInt(int start, int end) {
		Random rand = new Random();
		return rand.nextInt(end - start + 1) + start;
	}
	
	public void roundEnded(){
		if(currentChromoIndex < population.getPopulationSize()-1){
			currentChromoIndex++;
			currentChromo = population.get(currentChromoIndex);
		}else{
			currentChromoIndex = 0;
			currentChromo = population.get(currentChromoIndex);
		}
		roundCounter++;
		if(roundCounter%100==0){
			renewPopulation();
		}
		
	}
	
	public Chromosome getCurrentChromosome(){
		return currentChromo;
	}

}
