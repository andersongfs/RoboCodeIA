package genetictank;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public class GeneticAlgorithm {
	/**
	 * Params to geneticAlgorithm
	 */
	private int POPULATION_SIZE = 20;
	private int MIN_BULLET_POWER = 1;
	private int MAX_BULLET_POWER = 3;
	private int MAX_NUMBER_OF_GENERATIONS = 9999;
	private int RENEWER_POPULATION_RATE = 5;
	private int CHROMOSOME_PARAMS_SIZE = 9; // QUANTITY OF MOVES AND ROTATIONS THAT A CHROMOSOME MUST HAVE
	private int MUTATION_RATE = 20;

	private Population population;
	private int numberOfGenerations =0;
	
	private Chromosome currentChromo;
	private int currentChromoIndex = 0;
	private int roundCounter = 0;

	private static GeneticAlgorithm ag;
	
	private GeneticAlgorithm(){
		renewPopulation();
		
	}
	public static GeneticAlgorithm getInstance(){
		if(ag == null){
			ag = new GeneticAlgorithm();
		}
		return ag;
		
	}
	public void generateRandomPopulation(){
		population = new Population(POPULATION_SIZE);
		for(int i = 0; i < POPULATION_SIZE; i++){
			population.addChromosome(generateRandomChromosome(i));
		}
		currentChromo = population.get(currentChromoIndex);
	}

	private Chromosome generateRandomChromosome(int id) {
		Chromosome chromosome = new Chromosome(id);
		List<Double> rotations = new ArrayList<Double>();
		List<Double> moves = new ArrayList<Double>();

		for(int i = 0; i < CHROMOSOME_PARAMS_SIZE; i++) {
			rotations.add((double)randomInt(0, 180));
			moves.add((double)randomInt(100, 500));
		}

		chromosome.setRotations(rotations);
		chromosome.setDistances(moves);
		chromosome.setBulletPower(randomInt(MIN_BULLET_POWER, MAX_BULLET_POWER));
		return chromosome;

	}
	
	public void renewPopulation(){
		if(population == null ){
			generateRandomPopulation();
			return;
		}
		
		List<Chromosome> bestsChromosomes = selection(population);
		List<Chromosome> children = new ArrayList<Chromosome>();
		System.out.println((POPULATION_SIZE - RENEWER_POPULATION_RATE + 1)/2);
		for(int i = 0; i < (POPULATION_SIZE - RENEWER_POPULATION_RATE + 1)/2; i++){
			//TODO implement the roulette wheel method
			
			Chromosome parent1 = bestsChromosomes.get(randomInt(0, bestsChromosomes.size() - 1));
			Chromosome parent2 = bestsChromosomes.get(randomInt(0, bestsChromosomes.size() - 1));
			System.out.println("p1: " + parent1.getId());
			System.out.println("p2: " + parent2.getId());
			Chromosome[] newBorns = crossOver(parent1, parent2);
			children.add(newBorns[0]);
			children.add(newBorns[1]);
		}

		for(int i=0; i<population.getPopulationSize();i++){
			System.out.println("OLD: "+population.get(i).getId() + "; Fitness: " + population.get(i).getFitness());
		}
		List<Chromosome> newPopulation= new ArrayList<Chromosome>();
		for(int i =0; i<population.getPopulationSize();i++){
			newPopulation.add(population.get(i));
		}
		for (int i = 0; i < children.size()-5; i++) {
			newPopulation.set(i, children.get(i));
		}
		for (int i = 0; i < newPopulation.size(); i++) {
			newPopulation.get(i).setFitness(0);
		}

		numberOfGenerations++;
		System.out.println("Geração: "+numberOfGenerations);
		for(int i=0; i<population.getPopulationSize();i++){
			System.out.println("NEW: "+newPopulation.get(i).getId() + "; Fitness: " + newPopulation.get(i).getFitness());
		}
		
		population.setPopulation(newPopulation);
	}
	
	public int getNumberOfGenerations() {
		return numberOfGenerations;
	}

	public void setNumberOfGenerations(int numberOfGenerations) {
		this.numberOfGenerations = numberOfGenerations;
	}

	/**
	 * Select the best chromosomes from a given population based on the renewer rate
	 * @param population
	 * @return
	 */
	private List<Chromosome> selection(Population population){
		Collections.sort(population.getPopulation());
		int firstIndex = POPULATION_SIZE-RENEWER_POPULATION_RATE;
		return population.getPopulation().subList(firstIndex, POPULATION_SIZE-1);
	}
	
	/**
	 * returns a list with the two chromosomes generated by the crossOver of the two given ones 
	 * @param c1 
	 * @param c2
	 * @return
	 */
	private Chromosome[] crossOver(Chromosome c1, Chromosome c2){
		Chromosome r1 = new Chromosome(randomInt(0, 999999999));
		Chromosome r2 = new Chromosome(randomInt(0, 999999999));
		
		int splitPoint = randomInt(0, CHROMOSOME_PARAMS_SIZE-1);
		
		List<Double> rotationR1 = new ArrayList<Double>();
		List<Double> rotationR2 = new ArrayList<Double>();
		List<Double> distanceR1 = new ArrayList<Double>();
		List<Double> distanceR2 = new ArrayList<Double>();
		
		for (int i = 0; i < splitPoint; i++) {
			rotationR1.add(c1.getNextRotations().get(i));
			distanceR1.add(c1.getDistances().get(i));
		
			rotationR2.add(c2.getNextRotations().get(i));
			distanceR2.add(c2.getDistances().get(i));
		}
		
		for (int i = splitPoint; i < CHROMOSOME_PARAMS_SIZE; i++) {
			rotationR1.add(c2.getNextRotations().get(i));
			distanceR1.add(c2.getDistances().get(i));
			
			rotationR2.add(c1.getNextRotations().get(i));
			distanceR2.add(c1.getDistances().get(i));
		}
		r1.setDistances(distanceR1);
		r1.setRotations(rotationR1);
		
		r2.setDistances(distanceR2);
		r2.setRotations(rotationR2);
		
		if(randomInt(0,1)!= 0){
			r1.setBulletPower(c1.getBulletPower());
			r2.setBulletPower(c2.getBulletPower());
		}else{
			r1.setBulletPower(c2.getBulletPower());
			r2.setBulletPower(c1.getBulletPower());
		}
		
		mutate(r1);
		mutate(r2);

		Chromosome[] result = {r1,r2};
		return result;
	}
	
	private void mutate(Chromosome c){
		boolean isUpToMutation = randomInt(0, MUTATION_RATE) == 5;
		if(isUpToMutation){
			int rotationSize = c.getNextRotations().size()-1;
			int distancesSize = c.getDistances().size()-1;
			Double newRotation = (double) randomInt(0, 180);
			Double newDistance = (double) randomInt(100, 500);
			c.getNextRotations().set(randomInt(0, rotationSize), newRotation);
			c.getDistances().set(randomInt(0, distancesSize),newDistance);			
		}
	}

	private int randomInt(int start, int end) {
		Random rand = new Random();
		return rand.nextInt(end - start + 1) + start;
	}
	
	public void roundEnded(){
		if(currentChromoIndex < population.getPopulationSize()-1){
			currentChromoIndex++;
			currentChromo = population.get(currentChromoIndex);
		}else{
			currentChromoIndex = 0;
			currentChromo = population.get(currentChromoIndex);
		}
		roundCounter++;
		if(roundCounter%100==0){
			renewPopulation();
		}
		
	}
	
	public Chromosome getCurrentChromosome(){
		return currentChromo;
	}
	public void roundWon() {
		currentChromo.increaseFitness();
	}

}
